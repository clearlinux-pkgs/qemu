commit 5f12ca3822c9a8cfb422d6a0e421df836c281256
Author: Anthony Xu <anthony.xu@intel.com>
Date:   Mon Mar 14 14:20:15 2016 -0700

    There is thousands of system calls KVM_GET_SUPPORTED_CPUID during qemu boot,
    This patch caches cpuid info in qemu, reduces most of the system calls.
    
    Author: Chao Peng <chao.p.peng@linux.intel.com>
    Signed-off-by: Chao Peng <chao.p.peng@linux.intel.com>

diff --git a/include/sysemu/kvm.h b/include/sysemu/kvm.h
index 6695fa7..02a00f1 100644
--- a/include/sysemu/kvm.h
+++ b/include/sysemu/kvm.h
@@ -514,4 +514,7 @@ int kvm_set_one_reg(CPUState *cs, uint64_t id, void *source);
  * Returns: 0 on success, or a negative errno on failure.
  */
 int kvm_get_one_reg(CPUState *cs, uint64_t id, void *target);
+
+void kvm_arch_destroy(void);
+
 #endif
diff --git a/target-arm/kvm.c b/target-arm/kvm.c
index 969ab0b..7092bf1 100644
--- a/target-arm/kvm.c
+++ b/target-arm/kvm.c
@@ -168,6 +168,10 @@ int kvm_arch_init(MachineState *ms, KVMState *s)
     return 0;
 }
 
+void kvm_arch_destroy(void)
+{
+}
+
 unsigned long kvm_arch_vcpu_id(CPUState *cpu)
 {
     return cpu->cpu_index;
diff --git a/target-i386/kvm.c b/target-i386/kvm.c
index 7974acb..e31e5eb 100644
--- a/target-i386/kvm.c
+++ b/target-i386/kvm.c
@@ -102,6 +102,8 @@ static int has_xsave;
 static int has_xcrs;
 static int has_pit_state2;
 
+static struct kvm_cpuid2 *cpuid_cache;
+
 int kvm_has_pit_state2(void)
 {
     return has_pit_state2;
@@ -193,10 +195,15 @@ static struct kvm_cpuid2 *try_get_cpuid(KVMState *s, int max)
 static struct kvm_cpuid2 *get_supported_cpuid(KVMState *s)
 {
     struct kvm_cpuid2 *cpuid;
-    int max = 1;
+    int max = 64;
+
+    if (cpuid_cache != NULL) {
+        return cpuid_cache;
+    }
     while ((cpuid = try_get_cpuid(s, max)) == NULL) {
         max *= 2;
     }
+    cpuid_cache = cpuid;
     return cpuid;
 }
 
@@ -314,8 +321,6 @@ uint32_t kvm_arch_get_supported_cpuid(KVMState *s, uint32_t function,
         ret |= cpuid_1_edx & CPUID_EXT2_AMD_ALIASES;
     }
 
-    g_free(cpuid);
-
     /* fallback for older kernels */
     if ((function == KVM_CPUID_FEATURES) && !found) {
         ret = get_para_features(s);
@@ -1155,6 +1160,13 @@ int kvm_arch_init(MachineState *ms, KVMState *s)
     return 0;
 }
 
+void kvm_arch_destroy(void)
+{
+    if (cpuid_cache != NULL) {
+        g_free(cpuid_cache);
+    }
+}
+
 static void set_v8086_seg(struct kvm_segment *lhs, const SegmentCache *rhs)
 {
     lhs->selector = rhs->selector;
diff --git a/target-mips/kvm.c b/target-mips/kvm.c
index a8b8b32..875dcb6 100644
--- a/target-mips/kvm.c
+++ b/target-mips/kvm.c
@@ -50,6 +50,10 @@ int kvm_arch_init(MachineState *ms, KVMState *s)
     return 0;
 }
 
+void kvm_arch_destroy(void)
+{
+}
+
 int kvm_arch_init_vcpu(CPUState *cs)
 {
     int ret = 0;
diff --git a/target-ppc/kvm.c b/target-ppc/kvm.c
index 70ca296..6e7dd1e 100644
--- a/target-ppc/kvm.c
+++ b/target-ppc/kvm.c
@@ -127,6 +127,10 @@ int kvm_arch_init(MachineState *ms, KVMState *s)
     return 0;
 }
 
+void kvm_arch_destroy(void)
+{
+}
+
 static int kvm_arch_sync_sregs(PowerPCCPU *cpu)
 {
     CPUPPCState *cenv = &cpu->env;
diff --git a/target-s390x/kvm.c b/target-s390x/kvm.c
index 9b21b96..9a77a10 100644
--- a/target-s390x/kvm.c
+++ b/target-s390x/kvm.c
@@ -274,6 +274,10 @@ int kvm_arch_init(MachineState *ms, KVMState *s)
     return 0;
 }
 
+void kvm_arch_destroy(void)
+{
+}
+
 unsigned long kvm_arch_vcpu_id(CPUState *cpu)
 {
     return cpu->cpu_index;
diff --git a/vl.c b/vl.c
index b87e292..ceb4811 100644
--- a/vl.c
+++ b/vl.c
@@ -542,6 +542,9 @@ const char *qemu_get_vm_name(void)
 
 static void res_free(void)
 {
+    if (kvm_enabled()) {
+        kvm_arch_destroy();
+    }
     g_free(boot_splash_filedata);
     boot_splash_filedata = NULL;
 }
